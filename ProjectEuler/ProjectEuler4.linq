<Query Kind="Program" />

// ProjectEuler4: Largest palindrome product
// https://projecteuler.net/problem=4
void Main()
{
    Console.WriteLine("ProjectEuler4: Largest palindrome product");
    // test cases
    int numDigits = 2;
    ProjectEuler4 PE4_2dig = new ProjectEuler4(numDigits);
    Console.WriteLine("The largest palindrome product of {0}-digit numbers is: {1}", numDigits, PE4_2dig.GetAnswer());
    numDigits = 3;
    ProjectEuler4 PE4_3dig = new ProjectEuler4(numDigits);
    Console.WriteLine("The largest palindrome product of {0}-digit numbers is: {1}", numDigits, PE4_3dig.GetAnswer());
}

public class ProjectEuler4 
{
    private int numberOfDigits;
    
    // Constructor
    public ProjectEuler4(int numberOfDigits)
    {
        this.numberOfDigits = numberOfDigits;
    }
    
    // Generate list of all possible factors using the numberOfDigits input.
    private int[] PossibleFactors()
    {
        int firstNumber = 1;

        for (int i = numberOfDigits; i > 1; i--)
        {
            firstNumber *= 10;
        }
        int lastNumber = (firstNumber * 10) - 1;
        
        int[] possibleFactors = new int[(lastNumber - firstNumber) + 1];
        for (int i = 0; i < possibleFactors.Length; i++)
        {
            possibleFactors[i] = firstNumber + i;
        }
        return possibleFactors;
    }
    
    // Generate a list of all possible palindromes based on the array generated by PossibleFactors()
    private List<int> FindAllPalindromes(int[] nums)
    {
        List<int> allPalindromes = new List<int>();
        for (int minNum = IntUtils.Pow(nums[0], 2), maxNum = IntUtils.Pow(nums[nums.Length - 1], 2); 
            minNum <= maxNum; 
            minNum++)
        {
            if (IntUtils.IsPalindrome(minNum))
            {
                allPalindromes.Add(minNum);
            }
        }
        return allPalindromes;
    }

    // Iterate the list of allPalindromes starting with the largest, 
    // and returns the first instance of a palindrome number having both factors within the possibleFactors array.
    private int FindLargestPalindromeProduct(int[] possibleFactors, List<int> allPalindromes)
    {
        int firstFactor = possibleFactors[possibleFactors.Length - 1];
        int secondFactor;
        int floor = possibleFactors[0];
        int ceiling = possibleFactors[possibleFactors.Length - 1];
        int result = 0;
        //reverse the list to start with largest palindrome
        allPalindromes.Reverse();
        while (result == 0)
        {
            for (int ix = 0, n = allPalindromes[ix]; 
                ix < allPalindromes.Count;
                ix++, n = allPalindromes[ix])
            {
                for (int i = firstFactor; i > 0; i--)
                {
                    if (n % i == 0)
                    {
                        secondFactor = n / i;
                        if (secondFactor >= floor && secondFactor <= ceiling)
                        {
                            Console.WriteLine("Palindrome: {2} | firstFactor: {0} | secondFactor: {1}", i, secondFactor, n);
                            result = n;
                            return result;
                        }
                    }
                }
            }
        }
        return result;
    }

    // Get the answer to the problem.
    internal int GetAnswer()
    {
        int[] possibleFactors = PossibleFactors();
        List<int> allPalindromes = FindAllPalindromes(possibleFactors);
        return FindLargestPalindromeProduct(possibleFactors, allPalindromes);
    }
}
